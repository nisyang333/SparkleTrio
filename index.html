<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Daily Habit Tracker</title>
</head>
<body>
        <h1>Daily Health Habit Tracket ğŸš€</h1>
     <div class="container"> 
        <div class ="add-task-area"> 
            <input type="text"
            id="taskInput"
            placeholder="Add a new habit/task..."
            /> 

          <button class="primary-btn" onclick="addTask()">Add</button>>
          </div>

         <ul id="taskList"></ul>

        <div id="progressBar">
            <div id="progressFill"></div>
            </div>

            <div class="center">
                <b>Progress:</b> <span id="progressText">0%</span><br>
                <b>Streak:</b> <span id="streak">0</span>days
            </div>

            <button class="primary-btn" onclick="finishDay()">Finish Day & Reset</button>

            </div>

<script>
    const taskList = document.getElementById("taskList");
    const taskInput = document.getElementById("taskInput");
    const progressFill = document.getElementById("progressFill");
    const progressText = document.getElementById("progressText");
    const streakDisplay = document.getElementById("streak");
    
    // ---Initial Setup---

    //Defualt starting habits (from our Habit Tracker example)
    const initialHabits = [
        "Drink 8 glasses of water",
        "Sleep 8 hours",
        "Eat fruits/vegetables",
        "10 minutes of exercise"
    ];

    //load task from local storage ou use defaults
    let tasksData = JSON.parse(localStorage.getItem("habits")) || initialHabbits.map(text => ({text, done: false}));

    //load streak from local storage
    let streak = localStorage.getItem("streak") || 0;
    streakDisplay.textContent = streak;

    // Render tasks on load
    renderTasks();
    updateProgress();
    
    //core functions

    function renderTaks() {
        taskList.innerHTML = ''; 
        taskData.forEach((taskObj, index) => {
            addTaskItem(taskObj.text, taskObj.done, index);
        });
        }

        function saveTaks() {
            localStorage.setItem("habits", JSON.stringify(tasksData));
        }
        function updateProgress() {
            const total = tasksData.length;
            let completed =0;

            taskData.forEach(task => {
                if (task.done) completed++;
            });

            const percent = total > 0 ? Math.round((completed / total * 100)) : 0;
            progressFill.style.width = percent + "%";
            progressText.textContent = percent + "%";
        }

        // -- Task Manipulation Functions --

    function addTask() {
        const text = taskInput.value.trim();
        if (text) {

        tasksData.push({text: text, done: false});
        saveTasks();
        renderTasks();
        updateProgress();
        
        taskInput.value = "";//clear input
        } else {
            console.log("No task entered");

        }

        function addTaskItem(text, done, index) {
            const li = document.createElement("li");
            li.className = "habit";
            if (isDone) li.classList.add("done");

//task content area (checkbox and text)
const taskContent = document.createElement("div");
taskContent.className = "task-content";
const checkbox = document.createElement("input");
checkbox.type = "checkbox";
checkbox.checked = isDone;
checkbox.disable = isDone;
checkbox.addEventListener("change", () => handleCheckChange(index));

const taskSpan = document.createElement("span");
taskSpan.className = "task-text";
taskSpan.textContent = taskText;

taskContent.appendChild(checkbox);
taskContent.appendChild(taskSpan);
li.appendChild(taskContent);

//Buttons area
const taskButtons = document.createdElement("div");
taskButtons.className = "task-buttons";

const editBtn = createButton("Edit", () => handleEditClick(index,taskSpan),isDone);
const deleteBtn = createButton("Delete", () => handleDeleteClick(index),isDone);

taskButtons.appendChild (editBtn);
taskButtons.appendChild (deleteBtn);

li.appendChild(taskButtons);

taskList.appendChild(li);

}

function createButton(text, onClickHandler, isDisabled){
    const btn =document.createElement("button");
    btn.textContent = text;
    btn.disabled = isDisabled;
    btn.onclick = onClickHandler;
    return btn;
}
               
        }
    function handleCheckChange(index) {
        tasksData[index].done = true;
        saveTasks();
        renderTasks();
        updateProgress();
    }
    // Function to handle the "Finish Day & Reset" button
    function finishDay() {
        const total = tasksData.length;
        let completed = 0;
        tasksData.forEach(task => {
            if (task.done) completed++;
        });

        const allChecked = completed === total && total >0;

        if (allChecked){
            streak++;
            localStorage.setItem("streak", streak);
            streakDisplay.textContent = streak;
            alert(`Great job! You completed all "${total}" habits today!`);
        } else {
            streak =0;
            localStorage.setItem("streak", 0);
            streakDisplay.textContent = streak;
            alert("You missed some habits. Streak reset.");
        }
    }


    function handleDeleteClick(index) {
        if (confirm(`Are you sure you want to delete "${taskdata[index].text}"?`)) {
            taskData.splice(index, 1);
            saveTasks();
            renderTasks();
            updateProgress();
        }
    }

    function handleEditClick(index,taskSpan) {
        const currentText = tasksData[index].text;
        const newText = propmt("Edit your habit/task",currentText);

        if (newText !==null && newText.trim!() !== "" && newText.trim() !== currentText) {
             taskData.[index].text = newText.trim();
            saveTasks();
            renderTasks();
            updateProgress();
            //No need to update progress, status hasn't changed
        } else {
            console.log("No changes made or cancelled.");
        }

    }
            
    
    
{
    // Reset all task to not done for the next day
    taskData = taskData.map(task => ({
        text: task.text,
        done: false 
    }));

    saveTasks();
    renderTasks();  
    updateProgress();
}
</script>

</body>
</html>
